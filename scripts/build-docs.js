// @ts-check
import fs from 'fs'
import path from 'path'
import rimraf from 'rimraf'
import _r from 'regexr'
import {CommentAnalyzer, MarkdownRenderer} from 'readem'

// TODO fix regexr export structure
// @ts-ignore
const r = _r.default

/** Check if a file exists.
 * @param {string} filePath
 * @returns {Promise<boolean>}
 */
async function fileExists(filePath) {
    try {
        await fs.promises.access(filePath, fs.constants.F_OK)
        return true
    } catch (e) {
        return false
    }
}

async function main() {
    const docsMeta = await new CommentAnalyzer().analyze('./src')
    const renderer = new MarkdownRenderer()

    await new Promise((done, error) =>
        rimraf(path.resolve('./docs/api/'), {disableGlob: true}, err => (err ? error(err) : done()))
    )
    await renderer.render(docsMeta, './docs/api/')

    const navMarkdown = renderer.renderNav(docsMeta, {linePadStart: '  ', basePath: path.sep + 'api'})
    const sidebarFile = path.resolve('.', 'docs', '_sidebar.md')

    /** @type {string} */
    const startMarker = r.escape('<!-- __API_AUTOGENERATED_BEGIN__ -->')
    /** @type {string} */
    const endMarker = r.escape('<!-- __API_AUTOGENERATED_END__ -->')

    let content = (await fileExists(sidebarFile))
        ? await fs.promises.readFile(sidebarFile, {encoding: 'utf8'})
        : startMarker + endMarker

    content = content.replace(
        r`${startMarker}(\s|\S)*${endMarker}`,
        `${startMarker}
${navMarkdown}
${endMarker}`
    )

    await fs.promises.writeFile(sidebarFile, content, {encoding: 'utf8'})
}

main().catch(e => {
	// Make sure the process exits with a non-zero exit code on unhandle promise
	// rejections. This won't be necessary in an upcoming release of Node.js, in
	// which case it'll exit non-zero automatically. Time of writing this comment:
	// Node 13.8.
	console.error(e)
	process.exit(1)
})
